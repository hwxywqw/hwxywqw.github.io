<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CO-计组课设总结 | Hwxywqw</title>
  <meta name="keywords" content="">
  <meta name="description" content="CO-计组课设总结 | Hwxywqw">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="最近在收集UNESCO教科文组织世界遗产和非物质文化遗产系列的明信片和邮票，就整理了一下中国的，这大约是从世界的视角看来最能代表中国的东西了？于是忽然才发现自己对中国的了解实在堪称有限……惭愧。世界遗产大约去过三分之一，非遗了解的则属实不多，比如两个史诗都是第一次听说。感觉亦需长久的潜移默化的熏陶。 小时候曾说我的梦想是去深山老林里从事一些安静的工作，离群索居，远离任何人类。不论是去学地质学也好，">
<meta property="og:type" content="article">
<meta property="og:title" content="UNESCO-China">
<meta property="og:url" content="http://example.com/2023/06/11/UNESCO-China/index.html">
<meta property="og:site_name" content="Hwxywqw">
<meta property="og:description" content="最近在收集UNESCO教科文组织世界遗产和非物质文化遗产系列的明信片和邮票，就整理了一下中国的，这大约是从世界的视角看来最能代表中国的东西了？于是忽然才发现自己对中国的了解实在堪称有限……惭愧。世界遗产大约去过三分之一，非遗了解的则属实不多，比如两个史诗都是第一次听说。感觉亦需长久的潜移默化的熏陶。 小时候曾说我的梦想是去深山老林里从事一些安静的工作，离群索居，远离任何人类。不论是去学地质学也好，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/06/11/UNESCO-China/image-20230611212628982.png">
<meta property="article:published_time" content="2023-06-11T13:08:47.000Z">
<meta property="article:modified_time" content="2023-06-11T13:26:46.132Z">
<meta property="article:author" content="hwxywqw">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/06/11/UNESCO-China/image-20230611212628982.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.0.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="false" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>hwxywqw</span>
</div>

<div class="icon">
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(7)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="课程相关">
                        <i class="fold iconfont icon-right"></i>
                        
                        课程相关
                        <small>(3)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="课程相关<--->IT">
                                        
                                        IT
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="随笔">
                        
                        随笔
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="小工具">
                        
                        小工具
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="Post">
                        
                        Post
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="7">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 Post "
           href="/2023/06/11/UNESCO-China/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNESCO-China">UNESCO-China</span>
            <span class="post-date" title="2023-06-11 21:08:47">2023/06/11</span>
        </a>
        
        <a  class="全部文章 随笔 "
           href="/2023/02/11/Deporte/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Deporte">Deporte</span>
            <span class="post-date" title="2023-02-11 20:14:04">2023/02/11</span>
        </a>
        
        <a  class="全部文章 课程相关 IT "
           href="/2022/07/07/%E6%B1%89%E6%98%8E%E7%A0%81-HammingCode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="汉明码-HammingCode">汉明码-HammingCode</span>
            <span class="post-date" title="2022-07-07 13:08:36">2022/07/07</span>
        </a>
        
        <a  class="全部文章 课程相关 "
           href="/2022/05/06/%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81-RangeCoding/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区间编码_RangeCoding">区间编码_RangeCoding</span>
            <span class="post-date" title="2022-05-06 13:47:52">2022/05/06</span>
        </a>
        
        <a  class="全部文章 课程相关 "
           href="/2022/01/09/CO-%E8%AE%A1%E7%BB%84%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CO-计组课设总结">CO-计组课设总结</span>
            <span class="post-date" title="2022-01-09 23:05:31">2022/01/09</span>
        </a>
        
        <a  class="全部文章 小工具 "
           href="/2021/07/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="正则表达式使用指南">正则表达式使用指南</span>
            <span class="post-date" title="2021-07-18 23:07:28">2021/07/18</span>
        </a>
        
        <a  class="全部文章 小工具 "
           href="/2021/01/17/Shadowsocks%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shadowsocks使用指南">Shadowsocks使用指南</span>
            <span class="post-date" title="2021-01-17 01:15:24">2021/01/17</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-CO-计组课设总结" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">CO-计组课设总结</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="课程相关">课程相关</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-06-11 20:07:42'>2022-01-09 23:05</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#P1-Verilog%E9%83%A8%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">P1_Verilog部件设计与有限状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">知识总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E5%BB%BA%E6%A8%A1%EF%BC%9A"><span class="toc-text">组合逻辑建模：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC"><span class="toc-text">阻塞赋值与非阻塞赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D"><span class="toc-text">异步复位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A"><span class="toc-text">避坑指南：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8B%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">课下总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%8B%93%E5%B1%95%EF%BC%9A"><span class="toc-text">符号拓展：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-text">缩减运算符：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9A"><span class="toc-text">有限状态机：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E5%B7%A5%E5%85%B7%EF%BC%9A"><span class="toc-text">小工具：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P2-MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-text">P2_MIPS汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mars%E6%B5%8B%E6%8C%87%E4%BB%A4%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">Mars测指令数的方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91MIPS%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-text">命令行编译MIPS文件的格式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C"><span class="toc-text">自动运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%EF%BC%9A"><span class="toc-text">自己写一个：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VSCode-CodeRunner"><span class="toc-text">VSCode - CodeRunner</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81"><span class="toc-text">常用代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-text">宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%B1%82%E5%85%83%E7%B4%A0%E5%9C%B0%E5%9D%80"><span class="toc-text">矩阵求元素地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-text">栈操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syscall%E5%B8%B8%E7%94%A8%E8%AF%BB%E5%86%99"><span class="toc-text">syscall常用读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%A9%BA%E6%A0%BC%E5%92%8C%E6%8D%A2%E8%A1%8C"><span class="toc-text">输出空格和换行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-text">循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for"><span class="toc-text">for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while"><span class="toc-text">while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch"><span class="toc-text">switch</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8A"><span class="toc-text">课上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8B"><span class="toc-text">课下</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8B%E4%BD%9C%E4%B8%9A-01%E8%BF%B7%E5%AE%AB%EF%BC%9A"><span class="toc-text">课下作业_01迷宫：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8B%E4%BD%9C%E4%B8%9A-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%98%B6%E4%B9%98"><span class="toc-text">课下作业_高精度阶乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hanoi"><span class="toc-text">hanoi</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P3%EF%BC%9A%E5%8D%95%E5%91%A8%E6%9C%9FCPU-Logisim%E5%AE%9E%E7%8E%B0"><span class="toc-text">P3：单周期CPU (Logisim实现)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-text">设计方案：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8B%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-text">课下总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E4%B8%8A%E5%A4%8D%E7%9B%98%EF%BC%9A"><span class="toc-text">课上复盘：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAS"><span class="toc-text">JAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GRAY"><span class="toc-text">GRAY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MEMSET"><span class="toc-text">MEMSET</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    籍由这篇博客，简单总结上学期计算机组成原理课设。</p>
<p>​    计组课设一共有P0~P7七个阶段，P0~P2分别是对Logisim、Verilog和MIPS的预习内容，P3用Logisim实现单周期CPU，P4用Verilog实现单周期CPU，P5用Verilog实现流水线CPU，P6将指令集增加到四十余条，P7加入中断和异常。我做到P6，而<strong>博客只写到P3</strong>。后续~P6 Verilog部分的CPU设计、搭建过程，与工程化建模过程全部用excel记录，不放在这里了。</p>
<p><strong>P6的实现指令集：</strong></p>
<ul>
<li>LB、LBU、LH、LHU、LW、SB、SH、SW</li>
<li>ADD、ADDU、 SUB、 SUBU</li>
<li>MULT、 MULTU</li>
<li>DIV、 DIVU</li>
<li>SLL、 SRL、 SRA、 SLLV、 SRLV、SRAV</li>
<li>AND、OR、XOR、NOR、ADDI、ADDIU、ANDI、ORI、 XORI、LUI</li>
<li>SLT、SLTI、SLTIU、SLTU</li>
<li>BEQ、BNE、BLEZ、BGTZ、 BLTZ、BGEZ、J、JAL、JALR、JR</li>
<li>MFHI、MFLO、MTHI、MTLO</li>
</ul>
<p><strong>流水线CPU的设计思路：</strong></p>
<p><img src="image-20220210134014295.png" alt="顶层模块"></p>
<p>​    课设对于查重的要求很高，故而大家都按照自己的思路进行设计。有趣的是，我和室友在完成P5的初步搭建后尝试阅读对方的代码，发现思路大相径庭——虽然我们都是完全按照高小鹏老师的PPT搭建的，但我们却几乎看不懂对方在些什么。主要的差异有：B型指令的判断、对于不同模块的打包、转发、暂停等。给出两个例子：</p>
<ol>
<li>按单元纵向打包 &amp; 按功能横向打包<ul>
<li>我的顶层结构可看作纵向打包——分为FDEMW五阶段、五阶段相应的控制单元，和四个流水线寄存器，另附有转发控制和暂停控制两模块，共16个模块</li>
<li>室友采用横向打包——所有的7个控制单元组成总控，所有的组合逻辑和流水线寄存器组成流水线总体。</li>
</ul>
</li>
<li>分布式控制和集中式控制<ul>
<li>我的流水线的流水信号采用极简模式：只流水相当有限的几个信号，例如指令instruction信号，在每个单元的控制部分单独判断是什么指令，采用什么控制。好处在于，单元间的耦合低，可看作独立模块（符合我纵向按照单元打包的思想）。</li>
<li>室友的流水线只在最开始的地方判断一次，然后把所有控制信号向下流水。好处在于，大大减少指令类别判断，减少代码量（符合她横向按照功能打包的思想）。</li>
</ul>
</li>
</ol>
<h1 id="P1-Verilog部件设计与有限状态机"><a href="#P1-Verilog部件设计与有限状态机" class="headerlink" title="P1_Verilog部件设计与有限状态机"></a>P1_Verilog部件设计与有限状态机</h1><blockquote>
<p>前言：P1主题是Verilog。考察重点在于有限状态机，而有限状态机的搭建难点主要在于状态的设计。</p>
<p>Verilog作为一门新的语言，与c多有不同，但在掌握好基础语法以后一切创新与灵机一动都变得不再天方夜谭了。并行，正是最重要的特性。刚刚开始Verilog学习时曾一头雾水，到处搜寻网上所谓的“教程”，最后才恍然——教材才是最佳宝典呀。</p>
</blockquote>
<h2 id="知识总结："><a href="#知识总结：" class="headerlink" title="知识总结："></a>知识总结：</h2><h3 id="组合逻辑建模："><a href="#组合逻辑建模：" class="headerlink" title="组合逻辑建模："></a>组合逻辑建模：</h3><p>建模组合逻辑时，可以采用如下两种方式：</p>
<ul>
<li>always块配合reg型变量与阻塞赋值</li>
</ul>
<pre><code class="verilog">reg ans;
integer i;

always@(*)begin
    ans = 1&#39;b0;             //!!
    for (i=0; i&lt;32; i=i+1)
    ans = ans^in[i];
end
</code></pre>
<p><strong>注</strong>：不要漏掉赋初值，否则会<strong>输出x</strong>。这与我们一般说的使用initial进行初始化不同。在module中使用initial初始化reg会导致不可综合，所以那时我们一般在test bench里进行初始化。</p>
<ul>
<li>assign语句配合wire型变量</li>
</ul>
<pre><code class="verilog">assign result = ((if_begin == if_end) &amp;&amp; (yes == 1)) ? 1:0;
</code></pre>
<p>可以采用这种方式写一些小函数，例如：</p>
<pre><code class="verilog">assign isDigit = (in&gt;=&quot;0&quot; &amp;&amp; in&lt;=&quot;9&quot;)?1:0;
</code></pre>
<h3 id="阻塞赋值与非阻塞赋值"><a href="#阻塞赋值与非阻塞赋值" class="headerlink" title="阻塞赋值与非阻塞赋值"></a>阻塞赋值与非阻塞赋值</h3><p>​    关于阻塞赋值与非阻塞赋值的知识点，《Verilog与数字系统设计教程》第14章写得很好，看过以后顿觉豁然开朗。其中有介绍“<strong>层次化事件队列</strong>”相关知识——理解“仿真器首先按照仿真时间对事件进行排序，然后再在当前仿真时间里按照事件的优先级顺序进行排序。活跃事件是优先级最高的事件。”对于深入理解阻塞赋值与非阻塞赋值颇有助益。</p>
<p>​    需要注意：在活跃事件（阻塞赋值=、连续赋值assign，以及非阻塞赋值的右式计算……）之间，它们的执行顺序是<strong>随机的</strong>。</p>
<p><strong>为避免冒险竞争，下面列出一些需要时刻注意的要点：</strong></p>
<ul>
<li>时序电路建模，用非阻塞赋值</li>
<li>锁存器电路建模，用非阻塞赋值</li>
<li>always块建模组合逻辑，用阻塞赋值</li>
<li>同一个always块中建模时序和组合逻辑，用非阻塞赋值</li>
<li>同一个always块中不要同时用阻塞赋值和非阻塞赋值</li>
<li>不要在多个always块中为同一个变量赋值</li>
<li>赋值时不要使用#0延迟</li>
</ul>
<p><strong>举一个初学时可能感到困惑的例子：initial与阻塞赋值：</strong></p>
<p>test bench里面，initial里装的是阻塞赋值<code>=</code>，而在.v里，initial里装的是非阻塞赋值<code>&lt;=</code>，这个跟他们本身的用法相关。.v里赋值只进行一次，每个变量之间又没有关系，就可以攒一堆变量到最后一块赋值，而test bench是为了测试而赋值，这个<strong>赋值的结果必须立刻呈现</strong>，例如：</p>
<pre><code class="verilog">always begin
    a&lt;=2&#39;b11;
    #10
    a&lt;=2&#39;b00;
end
</code></pre>
<p>这个赋值出现在test bench里就是不合格的，a的值会始终为11。其实a究竟变成11还是00是薛定谔的，因为这两个赋值语句的优先级完全一样。</p>
<h3 id="异步复位"><a href="#异步复位" class="headerlink" title="异步复位"></a>异步复位</h3><pre><code class="verilog">always @(posedge clk, posedge reset) begin
    if (reset == 1) begin
        status &lt;= `S0;
    end else begin
        ……
    end
……
end
</code></pre>
<p>要注意不能写成下面那样，否则会产生竞争冒险，周期会错位，复位会提前。</p>
<pre><code class="verilog">always @(posedge clk) begin
……
end
always @(posedge reset) begin
……
end
</code></pre>
<h3 id="避坑指南："><a href="#避坑指南：" class="headerlink" title="避坑指南："></a>避坑指南：</h3><ul>
<li>文件开始处或许可以加上一行：``default_nettype none`，否则手误打错变量名时，Verilog会默认这是一个新的，wire型1bit的变量。（但是到了P5,P6可能不适用，因为变量太多了，一个一个定义十分麻烦）</li>
<li>仿真波形是黄色的xxxxx：看一下有没有把input手误敲成output，或者clk没有用always，而是手误用了assign。</li>
<li>位运算打括号：<code>a = (b&gt;&gt;3)+(c&lt;&lt;2)</code>要是写成<code>a = b&gt;&gt;3 + c&lt;&lt;2</code>可能会出谜之bug</li>
<li>仿真失败：上一个Isim忘记关了。把.v文件重新保存一次，语法检查完再仿真。</li>
<li>输出一直是0：<code>reg [32:0] output</code>。或者建module的时候把output建成input了，修正以后忘记把<strong>tb</strong>文件里被设成reg的output修改回wire。</li>
</ul>
<h2 id="课下总结："><a href="#课下总结：" class="headerlink" title="课下总结："></a>课下总结：</h2><h3 id="符号拓展："><a href="#符号拓展：" class="headerlink" title="符号拓展："></a>符号拓展：</h3><p><code>$signed</code>真的很不好用，直接用位拼接更方便：</p>
<pre><code class="verilog">&#123;&#123;16&#123;imm[15]&#125;&#125;, imm&#125;
</code></pre>
<h3 id="缩减运算符："><a href="#缩减运算符：" class="headerlink" title="缩减运算符："></a>缩减运算符：</h3><pre><code class="verilog">C=&amp;B
</code></pre>
<p>单目运算符，例如上面就是把B的每一位都与起来。非常好用。P1第二次上机的第一题是统计一个32位二进制数里，0有多少个，1有多少个；第一次上机的第一题是统计1有奇数个还是偶数个。如果不使用for循环+integer变量的话，建议考虑缩减运算符。</p>
<h3 id="有限状态机："><a href="#有限状态机：" class="headerlink" title="有限状态机："></a>有限状态机：</h3><blockquote>
<p>玄学状态机</p>
</blockquote>
<p>如果要识别cscore，那么输入cscs不能回到最初S0状态，应该回到S2状态。建立状态转移图要慎重再慎重！上机时第三题是复数格式<code>a+bi</code>检查，可以通过的样例有：</p>
<ul>
<li>0</li>
<li>+000</li>
<li>-0005i</li>
<li>-1+6i</li>
</ul>
<p>由于题目给的样例都是a+bi的形式，建立状态机时，有许多同学忽略了+5i这种样例，然后又挂了……我估算了一下，二百多个人，三次上机不算Pre，挂了两次的人有四五十个，心有戚戚！</p>
<h2 id="小工具："><a href="#小工具：" class="headerlink" title="小工具："></a>小工具：</h2><p><strong>vscode：</strong></p>
<p>竟发现周围有许多同学坚韧不拔地在ISE手敲代码。高亮和代码自动补全是好东西（）不过话说回来，整点基础的东西还是必要的，IDE虽好，可不要贪杯噢。比如IDEA虽有自动commit+push，可不要忘了怎么使用命令行。</p>
<p><strong>graphViz：</strong></p>
<p>有限状态机绘图可以使用，虽然有在线绘图（<a target="_blank" rel="noopener" href="https://csacademy.com/app/graph_editor/">Graph Editor</a>），但是本地画图总感觉心里踏实一点。尝试了一下pycharm配置环境，但是用起来很不顺手，最后还是选择vscode编辑.gv文件+命令行编译。cd到文件目录下即可：</p>
<pre><code class="shell">dot FSM.gv -Tpng -o image.png
</code></pre>
<p>效果如下：</p>
<p><img src="image-20220210133653414.png" alt="有限状态机F4"></p>
<p>更新一个pycharm的，可以自动生成函数调用图的小插件：pycallgraph（由于以graphViz为基础，故放于此处介绍）。以有限域运算（四则运算、扩展欧几里得、快速幂等）为例，给出一个效果图：</p>
<pre><code class="python">#! python3
# -*- coding: utf-8 -*-
from pycallgraph import PyCallGraph
from pycallgraph.output import GraphvizOutput
from pycallgraph import Config
from pycallgraph import GlobbingFilter
# 要生成函数调用图的文件
from GFinverse import *
from GFfastPower import *


if __name__ == &#39;__main__&#39;:
    graphviz = GraphvizOutput()
    graphviz.output_file = &#39;basic.png&#39;
    config = Config()
    config.max_depth = 5  # 控制最大追踪深度
    with PyCallGraph(output=graphviz, config=config):
        inverse(12)
        fastPower(49, 63108)
</code></pre>
<p><img src="image-20220310220816471.png" alt="image-20220310220816471"></p>
<p><strong>正则表达式：</strong></p>
<p><a target="_blank" rel="noopener" href="https://deerchao.cn/tools/wegester/">在线正则表达式测试器</a></p>
<h1 id="P2-MIPS汇编语言"><a href="#P2-MIPS汇编语言" class="headerlink" title="P2_MIPS汇编语言"></a>P2_MIPS汇编语言</h1><h2 id="Mars测指令数的方法："><a href="#Mars测指令数的方法：" class="headerlink" title="Mars测指令数的方法："></a>Mars测指令数的方法：</h2><h3 id="命令行编译MIPS文件的格式："><a href="#命令行编译MIPS文件的格式：" class="headerlink" title="命令行编译MIPS文件的格式："></a>命令行编译MIPS文件的格式：</h3><p>(具体在Help(F1)-Mars-Commend里面找，有什么需求按这个加options就行了。)</p>
<p>​        MARS can be run from a command interpreter to assemble and execute a MIPS program in a batch fashion. The format for running MARS from a command line is:</p>
<pre><code>java -jar mars.jar [options] program.asm [more files...] [ pa arg1 [more args...]]
</code></pre>
<p>​      Items in <em>[ ]</em> are optional. Valid options (not case sensitive, separated by spaces) are:    </p>
<table>
<thead>
<tr>
<th align="left">ic：</th>
<th>display instruction count;the number of MIPS basic instructions ‘executed’</th>
</tr>
</thead>
</table>
<pre><code>java -jar Mars4_5.jar ic xxx.asm
</code></pre>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>进入到当前目录<ol>
<li>进入到文件目录，按住Shift，右键打开Powershell，或者如下：</li>
<li>把.asm文件复制与Mars4_5.jar同一个安装目录</li>
<li>打开cmd</li>
<li>cd到Mars4_5.jar的安装目录下</li>
</ol>
</li>
<li>输入：java -jar Mars4_5.jar ic xxx.asm</li>
<li>输入参数（空格分开）</li>
</ol>
<h3 id="自动运行"><a href="#自动运行" class="headerlink" title="自动运行"></a>自动运行</h3><h4 id="自己写一个："><a href="#自己写一个：" class="headerlink" title="自己写一个："></a>自己写一个：</h4><p>我用了c，别的也行。</p>
<pre><code class="c">#include &lt;stdlib.h&gt;
int main()&#123;
//    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    system(&quot;copy D:\\workspace\\cs\\P2\\Q4_full.asm E:\\mars&quot;);    //.asm复制到安装目录下 
    system(&quot;java -jar Mars4_5.jar ic Q4_full.asm\n5&quot;);            //编译运行，指令在这里加 
    system(&quot;del E:\\mars\\Q4_full.asm&quot;);                        //用完删掉 
    system(&quot;pause&quot;); 
//    fclose(in);
    return 0;
&#125;
</code></pre>
<p>把生成的可执行文件放在跟Mars同一个安装目录，运行即可。</p>
<h4 id="VSCode-CodeRunner"><a href="#VSCode-CodeRunner" class="headerlink" title="VSCode - CodeRunner"></a>VSCode - CodeRunner</h4><p>settings.json中添加.asm文件的运行命令即可</p>
<h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><h4 id="矩阵求元素地址"><a href="#矩阵求元素地址" class="headerlink" title="矩阵求元素地址"></a>矩阵求元素地址</h4><pre><code>.macro address(%dst, %row, %column, %rank)  
        multu    %row, %rank
        mflo    %dst
        addu    %dst, %dst, %column
        sll        %dst, %dst, 2
.end_macro
</code></pre>
<h4 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h4><pre><code>.macro save(%tgt)
    sw        %tgt, 0($sp)
    addi    $sp, $sp, -4
.end_macro 
.macro load(%tgt)
    addi    $sp, $sp, 4
    lw        %tgt, 0($sp)
.end_macro 
</code></pre>
<h4 id="syscall常用读写"><a href="#syscall常用读写" class="headerlink" title="syscall常用读写"></a>syscall常用读写</h4><pre><code>.macro print_int(%tgt)
    move    $a0, %tgt
    li        $v0, 1
    syscall
.end_macro 
.macro read_int(%tgt)
    li        $v0, 5
    syscall
    move    %tgt, $v0
.end_macro 
</code></pre>
<h4 id="输出空格和换行"><a href="#输出空格和换行" class="headerlink" title="输出空格和换行"></a>输出空格和换行</h4><pre><code>.macro print_space
    la        $a0, str_space
    li        $v0, 4
    syscall
.end_macro 
.macro print_enter
    la        $a0, str_enter
    li        $v0, 4
    syscall
.end_macro 

str_space:    .asciiz &quot; &quot;
str_enter:     .asciiz &quot;\n&quot;  #字符串写最后避免内存出问题（不是4的倍数）
</code></pre>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><pre><code>move    $t0, $0
FOR:
    #
addi    $t0, $t0, 1
bne        $t0, $s0, FOR
</code></pre>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><pre><code>move    $t0, $0
WHILE:
    bne        $t0, $s0, END_WHILE
        #
    j        WHILE
END_WHILE:
</code></pre>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><pre><code>    b...CASE1
    b...CASE2
    ...
    j DEFAULT
CASE1:
    #
    j END_SWITCH
CASE2:
    #
    j END_SWITCH
...
DEFAULT:
    #
END_SWITCH
</code></pre>
<h2 id="课上"><a href="#课上" class="headerlink" title="课上"></a>课上</h2><p>课上三道题，先说一下内容：</p>
<ol>
<li>三位数反转。如果小于100或者大于999就输出一个报错，否则反转后输出，不要先导0。</li>
<li>输出组合数，比如$C_5^3$，告诉你5个里面选3个，按字典序输出就行了，考递归深搜dfs，跟全排列差不多。</li>
<li>长字符串里找子串，子串倒序后输出处理过的长字符串。考循环和内存读取。</li>
</ol>
<p>​        本来以为主要考递归，复习了很久，但是最后难点不是递归和栈，就第二题意思意思考了一点。第一题刚开始出了一个小bug，就是我分三次判断了（毕竟才三位数懒得循环），结果忘记给flag，导致输入101输出11，找出这个错以后前两道做得很顺，大概四十分钟做完。第三题给了c的样例代码，难以置信，竟然是错的。我看着那个代码觉得不靠谱啊就打开dev跑了一遍，果然输出了奇怪的东西，dev也还不能调试，只能肉眼debug，唉。最后也没有过，更不知道为什么错。大概5个测试点是AC，三个是Runtime Error，这是我从来没碰到过的报错，就算是指令数超了也应该是Tle才对。</p>
<p>​        </p>
<h2 id="课下"><a href="#课下" class="headerlink" title="课下"></a>课下</h2><h3 id="课下作业-01迷宫："><a href="#课下作业-01迷宫：" class="headerlink" title="课下作业_01迷宫："></a>课下作业_01迷宫：</h3><p>​        给出c语言代码。就是一个简单的dfs深搜，但是好久没写了还是有点手生。回忆了一下大一的知识，用了点小技巧把边界判断简化掉了——输入0代表这条路能走，在我的matrix里是1；输入1代表这条路不能走，在我的matrix里是0。我在整个迷宫外面再给他加一圈儿，这样边界都是0，也不用额外初始化，更不用额外判断。</p>
<pre><code class="c">int a[10][10];
int flag[10][10];
int cnt;
int at1, at2, tgt1, tgt2;
int dfs(int, int);

int main()&#123;
    int n, m;
    int i, j, k;
    int tmp;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (i=1; i&lt;=n; i++)&#123;
        for (j=1; j&lt;=m; j++)&#123;
            scanf(&quot;%d&quot;, &amp;tmp);
            if (tmp==0) a[i][j] = 1;
        &#125;
    &#125;
    scanf(&quot;%d %d %d %d&quot;, &amp;at1, &amp;at2, &amp;tgt1, &amp;tgt2);
    flag[at1][at2] = 1;
    dfs(at1, at2);
    printf(&quot;%d&quot;, cnt);
    return 0;
&#125;

int dfs(int row, int col)&#123; //行进顺序：上下左右
    if(a[row-1][col]==1 &amp;&amp; flag[row-1][col]==0)&#123;
        flag[row-1][col]=1;
        dfs(row-1, col);
        flag[row-1][col]=0;
    &#125; 
    else if(a[row+1][col]==1 &amp;&amp; flag[row+1][col]==0)&#123;
        flag[row+1][col]=1;
        dfs(row+1, col);
        flag[row+1][col]=0;
    &#125;
    else if(a[row][col-1]==1 &amp;&amp; flag[row][col-1]==0)&#123;
        flag[row][col-1]=1;
        dfs(row, col-1);
        flag[row][col-1]=0;
    &#125;
    else if(a[row][col+1]==1 &amp;&amp; flag[row][col+1]==0)&#123;
        flag[row][col+1]=1;
        dfs(row, col+1);
        flag[row][col+1]=0;
    &#125;
    else if (row==tgt1 &amp;&amp; col==tgt2)&#123;
        cnt++;
        return 0;
    &#125;
&#125;
</code></pre>
<p>手动编译一波：</p>
<pre><code class="mips">.data
.macro address(%dst, %row, %column, %rank)  
        multu    %row, %rank
        mflo    %dst
        addu    %dst, %dst, %column
        sll        %dst, %dst, 2
.end_macro
.macro save(%tgt)
    sw        %tgt, 0($sp)
    addi    $sp, $sp, -4
.end_macro 
.macro load(%tgt)
    addi    $sp, $sp, 4
    lw        %tgt, 0($sp)
.end_macro 
.macro print_int(%tgt)
    move    $a0, %tgt
    li        $v0, 1
    syscall
.end_macro 
.macro read_int(%tgt)
    li        $v0, 5
    syscall
    move    %tgt, $v0
.end_macro 

matrix:    .space 512
flag:    .space 512
#global variables
    #$s0: cnt
    #$s1: n
    #$s2: m
    #$s3: at1
    #$s4: at2
    #$s5: tg1
    #$s6: tg2
    #$s7: rank
#local variables
    #scan:
        #$t0: i
        #$t1: j
        #$t2: tmp
        #$t3: address
        #$t4: 1
    #dfs:
        #$t0: row
        #$t1: col
        #$t2: next row
        #$t3: next col
        #$t4: 1
        #$t5: address
        #$t6: tmp(row or col)
</code></pre>
<p>​        先给出变量与寄存器的对应关系，和一些简单的宏函数。其实也可以只记录at和target两点在一维矩阵中的地址，但是考虑到这样每次比较还得把元素地址算出来，肯定要跑好几条指令，$s寄存器也还够用，就之间存在寄存器里了。</p>
<p>​        不过我感觉自己对s寄存器和t寄存器的使用跟标准有点偏差。我好像一直习惯把全局变量放到s，局部变量放到t，不过这个跟程序员变量差别也不大。</p>
<pre><code class="mips">4.text 
read_int($s1)
read_int($s2)
li        $t4, 1
add        $s1, $s1, $t4
add        $s2, $s2, $t4
add        $s7, $s2, $t4
#li        $s7, 8
move    $t0, $t4
loop_i:
    move    $t1, $t4
    loop_j:
        read_int($t2)
        bne        $t2, $0, notroad
        address($t3, $t0, $t1, $s7)
        sw        $t4, matrix($t3)
        notroad:
    add        $t1, $t1, $t4
    bne        $t1, $s2, loop_j
add        $t0, $t0, $t4
bne        $t0, $s1, loop_i

read_int($s3)
read_int($s4)
read_int($s5)
read_int($s6)
address($t3, $s3, $s4, $s7)
sw        $t4, flag($t3)

move    $a1, $s3
move    $a2, $s4
jal        dfs

print_int($s0)
li        $v0, 10
syscall



dfs:
    save($ra)
    move    $t0, $a1
    move    $t1, $a2
    ##[row-1][col]
    sub        $t2, $t0, $t4
    address($t5, $t2, $t1, $s7)
    lw        $t6, matrix($t5)
    beq        $t6, $0, notthis1
        lw        $t6, flag($t5)
        bne        $t6, $0, notthis1
            sw        $t4, flag($t5)
                save($t0)
                save($t1)
                save($t5)
                move    $a1, $t2
                move    $a2, $t1
                jal        dfs
                load($t5)
                load($t1)
                load($t0)
            sw        $0,  flag($t5)
    notthis1:
    
    #[row+1][col]
    add        $t2, $t0, $t4
    address($t5, $t2, $t1, $s7)
    lw        $t6, matrix($t5)
    beq        $t6, $0, notthis2
        lw        $t6, flag($t5)
        bne        $t6, $0, notthis2
            sw        $t4, flag($t5)
                save($t0)
                save($t1)
                save($t5)
                move    $a1, $t2
                move    $a2, $t1
                jal        dfs
                load($t5)
                load($t1)
                load($t0)
            sw        $0,  flag($t5)
    notthis2:
    
    #[row][col-1]
    sub        $t3, $t1, $t4
    address($t5, $t0, $t3, $s7)
    lw        $t6, matrix($t5)
    beq        $t6, $0, notthis3
        lw        $t6, flag($t5)
        bne        $t6, $0, notthis3
            sw        $t4, flag($t5)
                save($t0)
                save($t1)
                save($t5)
                move    $a1, $t0
                move    $a2, $t3
                jal        dfs
                load($t5)
                load($t1)
                load($t0)
            sw        $0,  flag($t5)
    notthis3:
    
    #[row][col+1]
    add        $t3, $t1, $t4
    address($t5, $t0, $t3, $s7)
    lw        $t6, matrix($t5)
    beq        $t6, $0, notthis4
        lw        $t6, flag($t5)
        bne        $t6, $0, notthis4
            sw        $t4, flag($t5)
                save($t0)
                save($t1)
                save($t5)
                move    $a1, $t0
                move    $a2, $t3
                jal        dfs
                load($t5)
                load($t1)
                load($t0)
            sw        $0,  flag($t5)
    notthis4:
    
    bne        $t0, $s5, nottgt
    bne        $t1, $s6, nottgt
        add        $s0, $s0, $t4
    nottgt:
    
    load($ra)
    jr        $ra
</code></pre>
<p>​        上面手动编译就是纯粹体力劳动了，跟c的思路一样就没有添加额外的注释。dfs判断里面几个方向的判断代码几乎一模一样，一共可以写成一个宏+跳转，但我没写，有点后悔，看起来乱糟糟的。如果写了的话大概可以节约50行代码行数，不过命令数肯定没变化。中间有几个bug，记录一下：</p>
<ul>
<li>出入栈的时候没有保存address，也就是save($t5)，导致递归完成后把flag数组修改错了</li>
<li>进入递归的时候忘记把当前点标记为1</li>
<li>进入递归的时候忘记传参at1,at2</li>
</ul>
<p>用样例跑了一遍：</p>
<pre><code>已复制         1 个文件。
MARS 4.5  Copyright 2003-2014 Pete Sanderson and Kenneth Vollmar

4
5
0
0
1
0
0
1
0
0
0
1
1
0
1
0
1
1
0
0
0
0
1
1
4
5
2            //这个是输出
1929        //这个是执行的命令数

请按任意键继续. . .
</code></pre>
<h3 id="课下作业-高精度阶乘"><a href="#课下作业-高精度阶乘" class="headerlink" title="课下作业_高精度阶乘"></a>课下作业_高精度阶乘</h3><p>题解要求输出1000位以内，遂算一下大概称到多少是1000位：阶乘公式两边取10的对数即可。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int main()&#123;
    int n=0, i;
    double sum=log10(3628800), tmp=0;
    for (i=11; i&lt;=450; i++)&#123;
        tmp = log10(i);
        sum += tmp;
        n = (int)(sum+1);
        printf(&quot;%d:  %d\n&quot;, i, n);
    &#125; 
    return 0;
&#125;
</code></pre>
<p>跑出来结果如下。就算double不精准那也差不多，说明测试数据最多给到449，取个整算450.</p>
<pre><code>446:  990
447:  993
448:  995
449:  998
450:  1001
</code></pre>
<p>​        然后考虑用多少进制的问题。方便起见，用一个word也就是32位来存储一个单元，那最多可以到$2^{31}-1$。但是不能直接用这个数字，考虑到以下两个原因：</p>
<ul>
<li>不是10的整数倍，输出还需要进制转换，浪费指令数</li>
<li>尽量让乘法的结果只使用lo寄存器，不考虑hi寄存器</li>
</ul>
<p>于是采用[($2^{31}-1$)/450]以内最大的$10^k$作为进制数，也就是$10^6$（可惜，差一点点就到7次方了）。数组开到1000/6左右，取个整256。此外还需要考虑一些问题：</p>
<ul>
<li>某个单元有前导0时，输出字符串要补0位</li>
<li>乘到大数以后，低位会有很多0，跳过</li>
<li>高位同样有很多0不用乘，记录目前数字的最高位数。</li>
</ul>
<p>具体的MIPS代码实现就不放在这上面了。反正就是体力劳动。</p>
<h3 id="hanoi"><a href="#hanoi" class="headerlink" title="hanoi"></a>hanoi</h3><p>​        据说前几届考了汉诺塔，就写了一个简单版的，没有输出，只有计数，如下。刚上大一的时候就让我们学汉诺塔，但那时候又啥也不会，递归也看不懂，汉诺塔也不知道是什么东西，于是学的很痛苦，一直没能理解，每次做这道题之前都要在脑海里模拟一遍三个盘子怎么放，然后纠结于细节不敢下手。后来真的弄懂了才发现之前就是误入歧途——递归，就是你根本不需要在乎它究竟是怎么实现的，你只要告诉电脑，怎么把一个大问题拆分成若干个小问题，它自己就帮你跑出来了。真正需要程序员把握的是，如何去拆分，而不是细节如何实现。</p>
<pre><code class="mips">.text 
read_int($s1)
move    $a0, $s1
li        $a1, 1
li        $a2, 2
li        $a3, 3
jal        hanoi
print_int($s0)
li        $v0, 10
syscall

hanoi:
    save($ra)
    move    $t1, $a0
    move    $t2, $a1
    move    $t3, $a2
    move    $t4, $a3
    li        $t0, 1
    bne        $t0, $a0, notthis
        addi    $s0, $s0, 1
        load($ra)
        jr        $ra    
    notthis:
    addi    $t5, $t1, -1
    move    $a0, $t5
    move    $a1, $t2
    move    $a2, $t4
    move    $a3, $t3
    save($t1)
    save($t2)
    save($t3)
    save($t4)
    jal        hanoi
    load($t4)
    load($t3)
    load($t2)
    load($t1)
    addi    $s0, $s0, 1
    addi    $t5, $t1, -1
    move    $a0, $t5
    move    $a1, $t3
    move    $a2, $t2
    move    $a3, $t4
    save($t1)
    save($t2)
    save($t3)
    save($t4)
    jal        hanoi
    load($t4)
    load($t3)
    load($t2)
    load($t1)
    load($ra)
    jr        $ra    
</code></pre>
<h1 id="P3：单周期CPU-Logisim实现"><a href="#P3：单周期CPU-Logisim实现" class="headerlink" title="P3：单周期CPU (Logisim实现)"></a>P3：单周期CPU (Logisim实现)</h1><h2 id="设计方案："><a href="#设计方案：" class="headerlink" title="设计方案："></a>设计方案：</h2><p>课下要求实现指令集：addu, subu, ori, lw, sw, beq, lui, nop</p>
<p>跳转指令：j, jal, jr</p>
<ul>
<li>IFU（取指令单元）：内部包括 PC（程序计数器）、IM(指令存储器)及相关逻辑。<ul>
<li>PC 用寄存器实现，应具有<strong>异步复位</strong>功能，复位值为起始地址。</li>
<li><strong>起始地址：0x00000000。</strong></li>
<li>IM用 ROM 实现，容量为 32bit * 32。</li>
<li>因 IM 实际地址宽度仅为 5 位，故需要使用恰当的方法将 PC 中储存的地址同 IM 联系起来。</li>
</ul>
</li>
<li>GRF（通用寄存器组，也称为寄存器文件、寄存器堆）<ul>
<li>用具有写使能的寄存器实现，寄存器总数为 32 个，应具有<strong>异步复位</strong>功能。</li>
<li><strong>0 号寄存器</strong>的值始终保持为 0。其他寄存器<strong>初始值（复位后）均为 0</strong>，无需专门设置。</li>
</ul>
</li>
<li>ALU（算术逻辑单元）<ul>
<li>提供 32 位加、减、或运算及大小比较功能。</li>
<li>可以不支持溢出（不检测溢出）。</li>
</ul>
</li>
<li>DM（数据存储器）<ul>
<li>使用 RAM 实现，容量为 32bit * 32，应具有<strong>异步复位</strong>功能，复位值为 0x00000000。</li>
<li><strong>起始地址：0x00000000</strong>。</li>
<li>RAM 应使用双端口模式，即设置 RAM 的 <strong>Data Interface</strong> 属性为 <strong>Separate load and store ports</strong>。</li>
</ul>
</li>
<li>EXT：<ul>
<li>可以使用 Logisim 内置的 Bit Extender。</li>
</ul>
</li>
<li>Controller（控制器）<ul>
<li>使用与或门阵列构造控制信号</li>
</ul>
</li>
</ul>
<p><img src="image-20220210134525298.png" alt="顶层模块(Logisim单周期)"></p>
<h2 id="课下总结：-1"><a href="#课下总结：-1" class="headerlink" title="课下总结："></a>课下总结：</h2><ol>
<li>CPU设计方案<ul>
<li>实现指令集：addu, subu, ori, lw, sw, beq, lui, nop, j, jal, jr</li>
<li>CPU主要部件：IM, GRF, PC, NPC, ALU, DM, Controller， 采用工程化方法进行指令集建模。 控制信号的取值不计入功能部件，由与或阵列的组合逻辑直接得出。功能部件一列代表我要对 什么部件的值进行更改，也就是连接关系序偶右侧的部件。</li>
</ul>
</li>
<li>实现思路：按照PPT和讲解搭CPU的，关键点：<ul>
<li>分清指令执行的五大步骤（不止电路分清，脑子里更要分清！）</li>
<li>先确定新加指令的输入输出接口，然后添加控制信号，最后搭建数据通路</li>
</ul>
</li>
<li>测试：用讨论区的自动生成MIPS小程序， 关键点<ul>
<li>利用ori $1,$0,100这样的指令对每个寄存器进行赋值，初始化：生成随机数，或采用16位能表示的数最大或最小的数附近的数。然后加入测试用的指令。</li>
<li>对于addu，subu，ori等指令，构造大量指令进行测试，比较mars与logisim的结果即可。</li>
<li>对于beq，j等指令：采用分支跳转间夹杂特定赋值指令的方式，将代码分段，出现特定的值即代表某个跳转出问题。</li>
</ul>
</li>
<li>常见bug与解决方法：<ul>
<li>由于添加指令需要频繁修改模块，很有可能造成输入输出接口错位，记得修改完模块就看一遍appearance</li>
<li>输出xxxx：线没连上吧！</li>
<li>报错：outputs fewer than standard answer：跳转跳飞了吧！</li>
</ul>
</li>
</ol>
<h2 id="课上复盘："><a href="#课上复盘：" class="headerlink" title="课上复盘："></a>课上复盘：</h2><p>感觉P3的重点在于工程化建模，和控制信号和输入输出关系。如果这一部分课下做得很好，那课上就会非常顺利，难得一个小时刚过就AK（不过我旁边的巨神做P4还比我早一步走人，膜拜hh）然后最重要的是，把指令要求看清楚再开始做题，不要舍不得这五六分钟时间，思路和理解错了才是最膈应的。</p>
<h3 id="JAS"><a href="#JAS" class="headerlink" title="JAS"></a>JAS</h3><ul>
<li>编码：opcode[31:26]:110110;  target[25:0]</li>
<li>格式：jas  target</li>
<li>描述：跳转并将PC写入栈顶</li>
<li>操作：<ul>
<li>vaddr ← GPR[29]</li>
<li>Memory[vaddr] ← PC+4</li>
<li>PC ← PC{31…28}||target||00</li>
</ul>
</li>
<li>示例：jas  label</li>
</ul>
<p>这条指令算是三条当中最麻烦的了。是j与sw的复合，基本上就是将j和sw两条指令的输入输出连接投影到jas，但是控制信号的连接相对修改得就比较多。此外还需要将PC复位到0x00003000，跟Fibonacci数列那道题的方法一模一样。</p>
<h3 id="GRAY"><a href="#GRAY" class="headerlink" title="GRAY"></a>GRAY</h3><ul>
<li>编码：opcode[31:26]:000000;  rs[25:21];  00000;  rd[15:11];  00000;  function[5:0]:110001</li>
<li>格式：gray  rd, rs</li>
<li>描述：将GPR[rs]转为格雷码，结果写入GPR[rd]</li>
<li>操作：<ul>
<li>GPR[rd] ← GPR[rs]^(GPR[rs]&gt;&gt;1)</li>
<li>注：^为异或XOR，&gt;&gt;为逻辑右移</li>
</ul>
</li>
<li>示例：gray  $t0, $t1</li>
</ul>
<p>这个非常简单，就是常规的r型指令，ADDU稍微改一下ALU部分。ALU建模的时候注意可拓展性，指op最好做成三位或者四位的。</p>
<h3 id="MEMSET"><a href="#MEMSET" class="headerlink" title="MEMSET"></a>MEMSET</h3><ul>
<li>编码：opcode[31:26]:110100;  base[25:21];  rt[20:16];  offset[15:0]</li>
<li>格式：memset  rt, offset(base)</li>
<li>描述：将GPR[rt]的最后一个Byte赋给Memory[GPR[base]+offset]的每一个Byte</li>
<li>操作：<ul>
<li>vaddr ← GPR[base]+sign_ext(offset)</li>
<li>Memory[vaddr] ← GPR[rt]{7…0}||GPR[rt]{7…0}||GPR[rt]{7…0}||GPR[rt]{7…0}</li>
</ul>
</li>
<li>示例：memset  $t1, 8($t0)</li>
<li>其他：不考虑地址不对齐等异常情况</li>
</ul>
<p>同样很简单，基本等价于sw，稍微加两个MUX就可以了。</p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2020-2022 Hwxywqw
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
