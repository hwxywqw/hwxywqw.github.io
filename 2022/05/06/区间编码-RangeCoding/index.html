<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>区间编码_RangeCoding | Hwxywqw</title>
  <meta name="keywords" content="">
  <meta name="description" content="区间编码_RangeCoding | Hwxywqw">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="忽然想起来自己还有个博客，趁着假期整理一下。本来把这两年的一些小小的东西写了几篇文档，结果公式全乱了，扫兴。想起建博客时雄心壮志，建完就抛之脑后了，哈哈。能让我写点什么东西的几乎有且仅有DDL和偶尔复苏的文青之魂，更新一次博客又太麻烦。 此时坐在自己屋子的窗前，窗外是阴天，略有些冷。说是“自己屋子”，实际我这也是第一次住。自高考结束，只在去年五一假期匆匆回来陪室友看CP29玩了几天，好像成了游客一">
<meta property="og:type" content="article">
<meta property="og:title" content="重回上海">
<meta property="og:url" content="http://example.com/2024/04/27/%E9%87%8D%E5%9B%9E%E4%B8%8A%E6%B5%B7/index.html">
<meta property="og:site_name" content="Hwxywqw">
<meta property="og:description" content="忽然想起来自己还有个博客，趁着假期整理一下。本来把这两年的一些小小的东西写了几篇文档，结果公式全乱了，扫兴。想起建博客时雄心壮志，建完就抛之脑后了，哈哈。能让我写点什么东西的几乎有且仅有DDL和偶尔复苏的文青之魂，更新一次博客又太麻烦。 此时坐在自己屋子的窗前，窗外是阴天，略有些冷。说是“自己屋子”，实际我这也是第一次住。自高考结束，只在去年五一假期匆匆回来陪室友看CP29玩了几天，好像成了游客一">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-27T07:43:09.000Z">
<meta property="article:modified_time" content="2024-04-27T08:13:12.241Z">
<meta property="article:author" content="hwxywqw">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.0.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="false" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>hwxywqw</span>
</div>

<div class="icon">
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(9)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="随笔">
                        
                        随笔
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="文档">
                        
                        文档
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="小工具">
                        
                        小工具
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="9">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 随笔 "
           href="/2024/04/27/%E9%87%8D%E5%9B%9E%E4%B8%8A%E6%B5%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="重回上海">重回上海</span>
            <span class="post-date" title="2024-04-27 15:43:09">2024/04/27</span>
        </a>
        
        <a  class="全部文章 文档 "
           href="/2024/04/21/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86%E4%B8%8E%E6%B8%90%E8%BF%91%E5%9D%87%E5%88%86%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中心极限定理与渐近均分性">中心极限定理与渐近均分性</span>
            <span class="post-date" title="2024-04-21 21:59:42">2024/04/21</span>
        </a>
        
        <a  class="全部文章 随笔 "
           href="/2023/08/25/%E7%BB%99%E5%A4%A9%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="给天的一封信">给天的一封信</span>
            <span class="post-date" title="2023-08-25 16:14:02">2023/08/25</span>
        </a>
        
        <a  class="全部文章 随笔 "
           href="/2023/06/11/UNESCO-China/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNESCO-China">UNESCO-China</span>
            <span class="post-date" title="2023-06-11 21:08:47">2023/06/11</span>
        </a>
        
        <a  class="全部文章 文档 "
           href="/2022/05/06/%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81-RangeCoding/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区间编码_RangeCoding">区间编码_RangeCoding</span>
            <span class="post-date" title="2022-05-06 13:47:52">2022/05/06</span>
        </a>
        
        <a  class="全部文章 文档 "
           href="/2022/01/20/%E4%B8%80%E7%82%B9%E5%85%B3%E4%BA%8EFibonacci%E7%9A%84%E4%B8%9C%E8%A5%BF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="一点关于Fibonacci的东西">一点关于Fibonacci的东西</span>
            <span class="post-date" title="2022-01-20 11:15:24">2022/01/20</span>
        </a>
        
        <a  class="全部文章 小工具 "
           href="/2021/07/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="正则表达式使用指南">正则表达式使用指南</span>
            <span class="post-date" title="2021-07-18 23:07:28">2021/07/18</span>
        </a>
        
        <a  class="全部文章 文档 "
           href="/2021/02/04/%E7%9B%B4%E7%BA%BF%E6%8B%9F%E5%90%88%E4%B8%8EFourier%E5%B1%95%E5%BC%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="直线拟合与Fourier展开">直线拟合与Fourier展开</span>
            <span class="post-date" title="2021-02-04 11:15:24">2021/02/04</span>
        </a>
        
        <a  class="全部文章 小工具 "
           href="/2021/01/17/Shadowsocks%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shadowsocks使用指南">Shadowsocks使用指南</span>
            <span class="post-date" title="2021-01-17 01:15:24">2021/01/17</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-区间编码-RangeCoding" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">区间编码_RangeCoding</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="文档">文档</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-04-27 14:34:31'>2022-05-06 13:47</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">区间编码的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81"><span class="toc-text">1. 区间编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86"><span class="toc-text">1.1 区间编码原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2 区间编码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E4%B8%BB%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-text">1.2.1 主要算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881-%E5%8C%BA%E9%97%B4%E6%89%A9%E5%85%85%E4%B8%8E%E6%AD%A3%E8%A7%84%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.2 问题与解决方案1-区间扩充与正规化问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882-%E5%8C%BA%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.3 问题与解决方案2-区间初始化问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%883-%E7%BC%96%E7%A0%81%E7%BB%93%E6%9D%9F%E6%97%B6%E5%8C%BA%E9%97%B4%E6%94%B6%E6%95%9B%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.4 问题与解决方案3-编码结束时区间收敛问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%884-%E5%8C%BA%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.5 问题与解决方案4-区间自适应问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%96%87%E4%BB%B6-SHA256-%E5%80%BC%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="toc-text">1.3 文件 SHA256 值的验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-CLI%E4%BA%A4%E4%BA%92"><span class="toc-text">1.4 CLI交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E4%BB%A3%E7%A0%81%E9%B2%81%E6%A3%92%E6%80%A7%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">1.5 代码鲁棒性与安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%B5%81%E5%8E%8B%E7%BC%A9"><span class="toc-text">1.6 流压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98"><span class="toc-text">2. 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">2.1 重复性的文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-text">2.2 不同格式的压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-text">图片的压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BD%99%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-text">其余文件的压缩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%BB%91%E6%B4%9E%EF%BC%81"><span class="toc-text">2.3 黑洞！</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">区间编码的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81"><span class="toc-text">1. 区间编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86"><span class="toc-text">1.1 区间编码原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2 区间编码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E4%B8%BB%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-text">1.2.1 主要算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881-%E5%8C%BA%E9%97%B4%E6%89%A9%E5%85%85%E4%B8%8E%E6%AD%A3%E8%A7%84%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.2 问题与解决方案1-区间扩充与正规化问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882-%E5%8C%BA%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.3 问题与解决方案2-区间初始化问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%883-%E7%BC%96%E7%A0%81%E7%BB%93%E6%9D%9F%E6%97%B6%E5%8C%BA%E9%97%B4%E6%94%B6%E6%95%9B%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.4 问题与解决方案3-编码结束时区间收敛问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%884-%E5%8C%BA%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.5 问题与解决方案4-区间自适应问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%96%87%E4%BB%B6-SHA256-%E5%80%BC%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="toc-text">1.3 文件 SHA256 值的验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-CLI%E4%BA%A4%E4%BA%92"><span class="toc-text">1.4 CLI交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E4%BB%A3%E7%A0%81%E9%B2%81%E6%A3%92%E6%80%A7%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">1.5 代码鲁棒性与安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%B5%81%E5%8E%8B%E7%BC%A9"><span class="toc-text">1.6 流压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98"><span class="toc-text">2. 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">2.1 重复性的文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-text">2.2 不同格式的压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-text">图片的压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BD%99%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-text">其余文件的压缩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%BB%91%E6%B4%9E%EF%BC%81"><span class="toc-text">2.3 黑洞！</span></a></li></ol></li></ol></li></ol></div></p>
<h1 id="区间编码的实现"><a href="#区间编码的实现" class="headerlink" title="区间编码的实现"></a>区间编码的实现</h1><p>本文档来源于大二下信息论与编码的第一次大作业。当然，受限于当时姿势水平，算术编码只写了实现，完全没有看理论相关的内容。后来回顾的时候觉得也还蛮有意思的。Elements书上对应13.3节。</p>
<h2 id="1-区间编码"><a href="#1-区间编码" class="headerlink" title="1. 区间编码"></a>1. 区间编码</h2><p>区间编码是一种基于统计模型的无损压缩算法。G.N.N.Martin在1979年的Video&amp;Data Recording Conference上提交了一篇论文：《区间编码：去除数字信息中冗余的算法》（Range encoding: an algorithm for removing redundancy from a digitised message.），第一次提出了区间编码算法的思想。区间编码的实现都是基于该论文中描述的方法。尽管从本质上说区间编码与算术编码是相同的，但是根据该论文的发表年代，通常认为区间编码算法不受与算术编码算法相关的专利约束。正是因为如此，越来越多的研究人员将目光转向了区间编码算法。</p>
<h3 id="1-1-区间编码原理"><a href="#1-1-区间编码原理" class="headerlink" title="1.1 区间编码原理"></a>1.1 区间编码原理</h3><p>区间编码是算术编码的一种变型，它相较于Huffman编码而言，压缩率更高。因为Huffman以bit作为单位进行编码，这限制了压缩率；而区间编码是将需要编码的文件通过多次迭代映射到区间内的一个整数，使得单位bit能表示的信息量更大。</p>
<p><img src="arth.jpg" alt="img"></p>
<p>为了简单起见，以”AABCDAAB”为例介绍区间编码的原理。假设总区间的大小为200，统计词频后将符号映射到对应的整数区间内：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>频度</th>
<th>积累频度</th>
<th>映射区间</th>
<th>区间大小</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>4</td>
<td>4</td>
<td>[0, 99]</td>
<td>100</td>
</tr>
<tr>
<td>B</td>
<td>2</td>
<td>6</td>
<td>[100,149]</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>7</td>
<td>[150,174]</td>
<td>25</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>8</td>
<td>[175, 199]</td>
<td>25</td>
</tr>
</tbody></table>
<p>则，该字符串编码就是对于区间上下界的运算：</p>
<ul>
<li>原始区间: [0, 199]</li>
<li>编码A: [0, 99]</li>
<li>编码A: [0, 49]</li>
<li>编码B: [25, 37]</li>
<li>编码C: [35, 36]</li>
</ul>
<p>此时精度已经不足以完成剩余的编码，但是观察到，在已经确定区间范围 [35, 36] 后，无论之后的输入是什么，开头的 3 已经确定不会改变（相当于开头的3已经收敛了），因此可以输出 3 后，扩充区间，然后继续进行编码。</p>
<ul>
<li>输出3，扩充区间为 [500, 600]</li>
<li>编码D: [588, 600]</li>
<li>编码A: [588, 594]，输出5，扩充区间为[880, 940]</li>
<li>编码A: [880, 909]</li>
<li>编码B: [895, 901]</li>
</ul>
<p>此时遇到了一些麻烦——假设我们以三位数（10进制）为区间最大值，若接下来区间收敛到 [899, 900]，此时区间的精度不足以继续编码，但是首位数字不相同，达不到输出的条件，那么程序就不能顺利进行下去了，故而产生了两种解决方案：</p>
<ol>
<li>预留缓冲区，将开头的8和9移入缓冲区，待后续编码向900的某一边收敛后输出</li>
<li>扩充足够的区间，使得相较于编码的数而言，区间始终是足够大的</li>
</ol>
<p>因此，我们可以从这个小例子中总结出区间编码的两个主要组成部分——区间的计算，和区间正规化（指的就是区间扩充、区间收敛这两个问题）。下面从实现的角度阐述编码的要点、问题与解决方案。注意：实际上区间编码的实现是二进制的，而且区间的位数范围远比三位要大，这里只是为了方便演示所以选择十进制、区间大小三位。</p>
<h3 id="1-2-区间编码实现"><a href="#1-2-区间编码实现" class="headerlink" title="1.2 区间编码实现"></a>1.2 区间编码实现</h3><p>我将主要阐述以下几个部分：</p>
<ul>
<li>编码算法实现<ul>
<li>编码主要算法</li>
<li>解码主要算法</li>
</ul>
</li>
<li>问题与解决方案<ul>
<li>区间扩充与正规化问题</li>
<li>区间初始化问题</li>
<li>编码结束时区间收敛问题</li>
<li>区间自适应问题（未采用）</li>
</ul>
</li>
</ul>
<p>最后说两点：最初我以为，区间编码最最重要的，保证加解密一致的关键在于“高精度”，也就是尽可能减少整数运算的精度丢失，但这是及其困难的。但后来我发现，最重要的在于加解密过程中，运算精度的一致性，也就是说只要加解密遵循一套既定的精度取舍规则，那么精度高不高也无所谓了，当然，舍弃精度必然会影响压缩效率。我不知道是否有标准，这只是自己实现的一套规则。</p>
<p>此外，本次实现中以字节为单位进行编码。</p>
<h4 id="1-2-1-主要算法"><a href="#1-2-1-主要算法" class="headerlink" title="1.2.1 主要算法"></a>1.2.1 主要算法</h4><p>编码即迭代执行以下几个步骤：</p>
<ol>
<li>读入需要编码的码字</li>
<li>确定其映射区间</li>
<li>计算新的区间</li>
<li>高位相同时，输出高位编码并扩充区间</li>
</ol>
<p>主要代码如下（为简洁起见，进行部分修改）</p>
<pre><code class="c">while (读入8字节)&#123;
    // 区间计算
    R_all = high - low;
    tmp = low;
    low = tmp + R_all / scale * list[ch-1];
    high= tmp + R_all / scale * list[ch];

    // 从高位到低位比较区间上下界，若相同则加入输出缓冲区
    while ((high ^ low) &gt;&gt; MAXLEN == 0)&#123;
        加入缓冲区
        
        // 扩充区间
        low  &lt;&lt;= 1;
        high &lt;&lt;= 1;

        if (输出缓冲区达到8位)&#123;输出并清空缓冲区&#125;
    &#125;
&#125;
</code></pre>
<p>解码即迭代执行以下几个步骤：</p>
<ol>
<li>读入映射后的数</li>
<li>确定其所在区间</li>
<li>输出映射区间对应的码元</li>
<li>根据其所在区间计算新的区间</li>
</ol>
<p>主要代码如下（为简洁起见，进行部分修改）</p>
<pre><code class="c">while (1)&#123;
    // 从高位到低位比较区间上下界，若相同则丢弃
    while ((high ^ low) &gt;&gt; MAXLEN == 0)&#123;
        调整读入的数字
        
        // 扩充区间
        high &lt;&lt;= 1;
        low &lt;&lt;= 1;
        
        if (byte.cnt == 0)&#123;
            if (读入)
            else&#123;结尾处理&#125;
        &#125;
    &#125;
    输出映射区间对应的码元
    // 区间计算
    low = tmp + R_all / scale * list[ch-1];
    high= tmp + R_all / scale * list[ch];
&#125;
</code></pre>
<h4 id="1-2-2-问题与解决方案1-区间扩充与正规化问题"><a href="#1-2-2-问题与解决方案1-区间扩充与正规化问题" class="headerlink" title="1.2.2 问题与解决方案1-区间扩充与正规化问题"></a>1.2.2 问题与解决方案1-区间扩充与正规化问题</h4><p>区间编码的一个大难题就是精度丢失。丢失精度导致解码失败的文件，在16进制形式下打开时多呈现为：从错误节点开始连续出现 <code>0xFF</code> 或 <code>0x00</code> 。直观上理解，这是因为越界翻译成了上一个或者下一个区间的元素，导致区间从上越界或从下越界。为了防止精度丢失导致编码失败，必须保证现有的区间长度不能太小。这就涉及到了区间的扩充与正规化。</p>
<p>我最初的实现思路为：当区间过小时，就需要扩充，然后发现这个“过小”是难以界定的，有时算着算着区间就收敛了。因此我不再判断区间是否太小，而是在输出高位的同时进行低位扩充，使得计算区间的有效长度始终保持不变。这就相当于区间的上下界始终维持着一个较大的差。</p>
<p><img src="image-20220428000133260.png" alt="image-20220428000133260"></p>
<p>再者就是要防止收敛，例如7999999和8000000。我在区间的有效位左边预留了17位缓冲区，画一个示意图：</p>
<p><img src="image-20220428000118688.png" alt="image-20220428000118688"></p>
<h4 id="1-2-3-问题与解决方案2-区间初始化问题"><a href="#1-2-3-问题与解决方案2-区间初始化问题" class="headerlink" title="1.2.3 问题与解决方案2-区间初始化问题"></a>1.2.3 问题与解决方案2-区间初始化问题</h4><p>若完全按照理论上可行的区间编码方式进行编码，那么输出的编码文件会是一串长长的数字，但是这串数字所对应的最初的区间是无法确定的。举个栗子，假设有如下区间映射：</p>
<ul>
<li>A: [0, 99]</li>
<li>B: [100, 9999]</li>
</ul>
<p>读入的数字为99999999，那么根本无法译码，因为不知道这一串数字在第一个区间究竟代表9，还是99，还是9999。</p>
<p>解决方案是，在头部输出一串0来帮助确认位置——这相当于规定了一个固定的初始位数，就好像c语言中输出数字时会使用 <code>%08x</code> 来规定输出位数一样。还是上面的例子，此时我规定初始区间大小为 [0,9999] ，读入的数字变成了0099999999，那么我就可以按照初始区间，将这一串数字识别为0099-999999，从而确定第一个区间为 [0,99]。</p>
<p>我在具体实现中将这个初始区间的长度也定为 47。主要是考虑到不能太大（相较于64位ULL），也不能太小（相较于原始的映射区间），因此与计算区间相等就可以了。</p>
<h4 id="1-2-4-问题与解决方案3-编码结束时区间收敛问题"><a href="#1-2-4-问题与解决方案3-编码结束时区间收敛问题" class="headerlink" title="1.2.4 问题与解决方案3-编码结束时区间收敛问题"></a>1.2.4 问题与解决方案3-编码结束时区间收敛问题</h4><p>算到最后，我们得到的是区间上下界两个数值，但最后需要的是一个数，所以我直接取了平均数。当然这个问题是很好解决的——在上下区间里任取一个数都可以，因为它所代表的区间是不变的。</p>
<p>此外，解码时也有同样的困惑——什么时候结束呢？我的解决方案是在文件信息里加入了原始文件的大小，在解码收尾时判断：如果大小相等了就结束。</p>
<h4 id="1-2-5-问题与解决方案4-区间自适应问题"><a href="#1-2-5-问题与解决方案4-区间自适应问题" class="headerlink" title="1.2.5 问题与解决方案4-区间自适应问题"></a>1.2.5 问题与解决方案4-区间自适应问题</h4><p>这是在计算映射区间时碰到的问题。比如说我给了一个全都是0的文件，那么假若我不知道接下来输入什么，是否还要给其余的数预留空间呢？不给，映射区间就会非对称得太厉害；给了，可能造成浪费。</p>
<p>我最后的解决方案是——如果没有某个数的输入，则预留最低限度区间宽 8（相较于整个区间$2^{32}$的大小而言，即便造成浪费也是微乎其微的。如果某一区间过大，则进行削减。但是，最后这个设想没有启用，因为暂时不需要考虑自适应的问题。</p>
<p>此外，我还查阅到了存储区间的另一种有效方法——询问树+更新树，通过索引获得区间。但是实现起来很麻烦，而且我是按字节存储的，256个符号对应的区间检索起来也挺快的。</p>
<h3 id="1-3-文件-SHA256-值的验证"><a href="#1-3-文件-SHA256-值的验证" class="headerlink" title="1.3 文件 SHA256 值的验证"></a>1.3 文件 SHA256 值的验证</h3><img src="image-20220427223630062.png" alt="image-20220427223630062" style="zoom:80%;" />



<h3 id="1-4-CLI交互"><a href="#1-4-CLI交互" class="headerlink" title="1.4 CLI交互"></a>1.4 CLI交互</h3><p>采用python的argparse来实现这个功能。 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/howto/argparse.html#id1">Argparse 教程 — Python 3.10.4 文档</a></p>
<p>由于是用c实现的编码，故而不能直接通过函数来进行编码和解码，我就让python跑c编译后的可执行文件来编码和解码。个人感觉如果下一次实现同样的CLI交互的话，最好保证两者是一致的，因为不同语言之间的沟通不太好。比方说我之前还想要实现一个压缩进度条的功能，但不知道怎么弄，如果是python调用python实现的函数的话，就很方便。</p>
<p>支持以下功能：</p>
<ul>
<li>  -h, –help</li>
<li>  -e , –encode  编码</li>
<li>  -d , –decode  解码</li>
<li>  -r, –ratio  编码时求压缩比</li>
<li>  -s , –sha256  求文件SHA256值（需要输入完整文件路径）</li>
<li>  –dstm   流密码</li>
</ul>
<p>c的参数传递通过main函数：</p>
<pre><code class="c">int main(int argc, char *argv[])&#123;
    char namein[200];
    strcpy(namein, argv[1]);
&#125;
</code></pre>
<p>python的调用通过subprocess库：</p>
<pre><code class="python">p = subprocess.Popen(&quot;encode.exe&quot; + &quot; &quot; + file)
</code></pre>
<p>CLI交互界面如下：</p>
<img src="image-20220428144350937.png" alt="image-20220428144350937" style="zoom:80%;" />

<p>放一小段源代码，以此为示例：</p>
<pre><code class="python">if __name__ == &#39;__main__&#39;:
    DESCR = r&#39;&#39;&#39;
    Encode or decode a file using Region Coding (a variant of arithmetic coding).
    The encoded file consists of two parts: the encoded file, and the file information, ending with .rep
    Example:
        python CLI.py -h
        python CLI.py -e test.pdf -r
        python CLI.py -d test.rep
        python CLI.py -s D:\workspace\InformExp\test.pdf
    &#39;&#39;&#39;
    parser = argparse.ArgumentParser(usage=&#39;python %(prog)s [option]... (, [FILE]...)&#39;,
                                     description=DESCR,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument(&quot;-e&quot;, &quot;--encode&quot;, help=&quot;The target file to encode.&quot;)
    parser.add_argument(&quot;-d&quot;, &quot;--decode&quot;, help=&quot;The target file to decode.&quot;)
    parser.add_argument(&quot;-r&quot;, &quot;--ratio&quot;,  help=&quot;print the compress ratio when encoding&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;-s&quot;, &quot;--sha256&quot;, help=&quot;print the SHA256 of one target file. Enter the full file path.&quot;)
    parser.add_argument(&quot;--dstm&quot;, help=&quot;decode the file in stream&quot;)

    args = parser.parse_args()

    if args.encode:
        file = args.encode
        file_compress = os.path.splitext(file)[0] + &quot;.rep&quot;
        p = subprocess.Popen(&quot;encode.exe&quot; + &quot; &quot; + file)
        print(&quot;Encode to %s&quot; % file_compress)
        time.sleep(1)
        if args.ratio:
            fsize = os.path.getsize(file)
            csize = os.path.getsize(file_compress)
            print(&quot;compress ratio is %.2f%%&quot; % (100 * csize / fsize))
</code></pre>
<h3 id="1-5-代码鲁棒性与安全性"><a href="#1-5-代码鲁棒性与安全性" class="headerlink" title="1.5 代码鲁棒性与安全性"></a>1.5 代码鲁棒性与安全性</h3><ul>
<li>文件信息单独储存还是合并到压缩文件中是可选的，并且加入文件大小和 SHA256 值（可选）防止被篡改。</li>
<li>通过文件后缀.rep来标识加密后的文件</li>
<li>对于空文件或者只有一种输入的文件是可编码的</li>
</ul>
<h3 id="1-6-流压缩"><a href="#1-6-流压缩" class="headerlink" title="1.6 流压缩"></a>1.6 流压缩</h3><pre><code class="shell">python CLI.py -dstm test.txt
</code></pre>
<p>单次缓冲区定为 2048 Byte，分多次加密。</p>
<img src="image-20220428205920949.png" alt="image-20220428205920949"  />

<p><img src="image-20220428144856805.png" alt="image-20220428144856805"></p>
<h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h2><h3 id="2-1-重复性的文件结构"><a href="#2-1-重复性的文件结构" class="headerlink" title="2.1 重复性的文件结构"></a>2.1 重复性的文件结构</h3><p>testfile1的文件内容是： 256 字节 0x00，256 字节 0x01，256 字节 0x02，…，256 字节 0xff，总计 64KiB。testfile2的文件内容是： 16 字节 0x00，16 字节 0xFF，16 字节 0x00，…，总计 8KiB。</p>
<pre><code class="shell">PS D:\workspace\InformExp&gt; python CLI.py -e testfile1.txt -r
Encode to testfile1.rep
compress ratio is 100.01%

PS D:\workspace\InformExp&gt; python CLI.py -e testfile2.txt -r
Encode to testfile2.rep
compress ratio is 12.60%
</code></pre>
<p>对上述两个文件进行编码，效果如上：</p>
<ul>
<li>testfile1进行编码后，其编码文件与原始文件的体积比大于100%，增大了文件大小</li>
<li>testfile2进行编码后，其编码文件与原始文件的体积比约为12%，起到很好的压缩效果</li>
</ul>
<p>区间编码是通过递推计算区间上下界对应的范围，来对文件进行编码的。我使用了二进制的方式来读取文件，导致一次进行编码的位数是确定的 8 bits（也就是一字节）。testfile1若按照字节来看，恰好是 <code>0x00</code> 到 <code>0xFF</code> 的均匀分布，这也就导致统计词频后，每个码元对应的区间大小是相同的。假设原始区间为1，那么无论下一个输入是什么，区间都会被缩小到1/256，依旧需要 8 bits 来表示。因此，文件不能被成功压缩。</p>
<p>至于压缩后文件稍微变大，有以下原因：</p>
<ul>
<li>头部加入了一些文件信息</li>
<li>为便于区间初始化，编码时会输出约 1 字节冗余的0</li>
<li>编码结束后，区间取中间值收敛，会输出约3字节冗余编码</li>
</ul>
<p><img src="image-20220427203009250.png" alt="image-20220427203009250"></p>
<p>对区间编码后的文件进行以字节为单位的频率统计，可以发现区间编码并没能够破环文件自身的重复性结构，这是因为区间编码是基于词频的编码，单独码元的从其词频所在区间到实数一段区间的映射。此时应当在区间编码前先使用可以破环此种结构的LZ编码——这种编码是基于字典的，天生对这种重复性文件具有很好的压缩效果。</p>
<h3 id="2-2-不同格式的压缩"><a href="#2-2-不同格式的压缩" class="headerlink" title="2.2 不同格式的压缩"></a>2.2 不同格式的压缩</h3><h4 id="图片的压缩"><a href="#图片的压缩" class="headerlink" title="图片的压缩"></a>图片的压缩</h4><pre><code class="shell">PS D:\workspace\InformExp&gt; python CLI.py -e dog1.jpeg -r
Encode to dog1.rep
compress ratio is 99.16%

PS D:\workspace\InformExp&gt; python CLI.py -e dog2.bmp -r
Encode to dog2.rep
compress ratio is 62.04%
</code></pre>
<p>为防止图片保存时的质量损失影响压缩效果，我先将图片保存为jpeg格式，再重新保存为bmp格式。统计词频如下表。可以看到：</p>
<ul>
<li>jpeg格式下，字节频率分布较为均匀。这是因为jpeg已经是经过压缩的格式，再次进行编码，优化空间已经不大了，所以编码后体积比为99.16%。</li>
<li>bmp格式下，字节频率分布极为不均匀——其中 <code>0xFF</code> 特别多。这是因为bmp格式通过位映射存储（因此文件体积也会较大），其文件的编码与图片具体的颜色关系密切。这种不均匀的词频分布是有利于区间编码的，所以达到了62.04%的压缩效果。</li>
</ul>
<table>
<thead>
<tr>
<th>jpeg</th>
<th>bmp</th>
</tr>
</thead>
<tbody><tr>
<td><img src="image-20220427210656022.png" alt="image-20220427210656022"></td>
<td><img src="image-20220427210702636.png" alt="image-20220427210702636"></td>
</tr>
<tr>
<td><img src="Figure_2.png" alt="Figure_2"></td>
<td><img src="Figure_1.png" alt="Figure_1"></td>
</tr>
</tbody></table>
<h4 id="其余文件的压缩"><a href="#其余文件的压缩" class="headerlink" title="其余文件的压缩"></a>其余文件的压缩</h4><pre><code class="shell">PS D:\workspace\InformExp&gt; python CLI.py -e decode.exe -r
Encode to decode.rep
compress ratio is 67.27%
</code></pre>
<p>我压缩了解码用的.exe文件，效果非常好，猜测该文件的字节频率分布不均匀。统计后发现确实如此——其中有非常多的 <code>0xFF</code>。此外，我对其他一些常见文件类型也进行了词频统计，发现压缩效果与其文件结构关系密切。</p>
<table>
<thead>
<tr>
<th>文件格式</th>
<th>统计图</th>
</tr>
</thead>
<tbody><tr>
<td><img src="Figure_docx.png" alt="Figure_docx" style="zoom: 25%;" /></td>
<td><img src="Figure_cpp.png" alt="Figure_cpp" style="zoom: 25%;" /></td>
</tr>
<tr>
<td>.docx</td>
<td>.cpp</td>
</tr>
<tr>
<td><img src="Figure_jpg.png" alt="Figure_jpg" style="zoom: 25%;" /></td>
<td><img src="Figure_exe.png" alt="Figure_exe" style="zoom: 25%;" /></td>
</tr>
<tr>
<td>.jpg</td>
<td>.exe</td>
</tr>
<tr>
<td><img src="Figure_png.png" alt="Figure_png" style="zoom:25%;" /></td>
<td><img src="Figure_mkv.png" alt="Figure_mkv" style="zoom: 25%;" /></td>
</tr>
<tr>
<td>.png</td>
<td>.mkv</td>
</tr>
<tr>
<td><img src="Figure_pdf.png" alt="Figure_pdf" style="zoom:25%;" /></td>
<td><img src="Figure_pptx.png" alt="Figure_pptx" style="zoom:25%;" /></td>
</tr>
<tr>
<td>.pdf</td>
<td>.pptx</td>
</tr>
</tbody></table>
<h3 id="2-3-黑洞！"><a href="#2-3-黑洞！" class="headerlink" title="2.3 黑洞！"></a>2.3 黑洞！</h3><p>如果将一个超大的文件压缩几百次，$L_n/n$也只会无限趋近于其极限，也就是熵$H(S)$，而不会。这是因为一张图片所含有的信息量是固定不变的，不能用无限小的编码来表示。下图分别为进行一轮编码和十轮编码后，文件的字节统计结构。可以看到此时分布已经非常均匀了——这样再压缩下去也不会有多好的效果。</p>
<p><img src="Figure_3.png" alt="一轮编码"></p>
<p><img src="Figure_4.png" alt="十轮编码"></p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2020-2022 Hwxywqw
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
